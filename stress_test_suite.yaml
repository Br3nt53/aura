{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red183\green111\blue247;\red23\green24\blue24;\red202\green202\blue202;
\red212\green212\blue212;\red113\green192\blue131;\red246\green124\blue48;\red109\green115\blue120;}
{\*\expandedcolortbl;;\cssrgb\c77255\c54118\c97647;\cssrgb\c11765\c12157\c12549;\cssrgb\c83137\c83137\c83137;
\cssrgb\c86275\c86275\c86275;\cssrgb\c50588\c78824\c58431;\cssrgb\c98039\c56471\c24314;\cssrgb\c50196\c52549\c54510;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 import\cf4 \strokec4  rclpy\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  rclpy.node \cf2 \strokec2 import\cf4 \strokec4  Node\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  geometry_msgs.msg \cf2 \strokec2 import\cf4 \strokec4  PoseStamped\cb1 \
\cf2 \cb3 \strokec2 from\cf4 \strokec4  aura_interfaces.msg \cf2 \strokec2 import\cf4 \strokec4  AuraRfHint\cf5 \strokec5 ,\cf4 \strokec4  AuraRfHintList\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  json\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  math\cb1 \
\cf2 \cb3 \strokec2 import\cf4 \strokec4  random\cb1 \
\
\cf2 \cb3 \strokec2 class\cf4 \strokec4  MockRfNode\cf5 \strokec5 (\cf4 \strokec4 Node\cf5 \strokec5 ):\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf2 \strokec2 def\cf4 \strokec4  \cf2 \strokec2 __init__\cf5 \strokec5 (\cf2 \strokec2 self\cf5 \strokec5 ):\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 super\cf5 \strokec5 ()\cf4 \strokec4 .\cf2 \strokec2 __init__\cf5 \strokec5 (\cf6 \strokec6 'mock_rf_node'\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .subscription = \cf2 \strokec2 self\cf4 \strokec4 .create_subscription\cf5 \strokec5 (\cf4 \cb1 \strokec4 \
\cb3             PoseStamped\cf5 \strokec5 ,\cf4 \cb1 \strokec4 \
\cb3             \cf6 \strokec6 '/aura/ground_truth'\cf5 \strokec5 ,\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 self\cf4 \strokec4 .gt_callback\cf5 \strokec5 ,\cf4 \cb1 \strokec4 \
\cb3             \cf7 \strokec7 10\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .publisher_ = \cf2 \strokec2 self\cf4 \strokec4 .create_publisher\cf5 \strokec5 (\cf4 \strokec4 AuraRfHintList\cf5 \strokec5 ,\cf4 \strokec4  \cf6 \strokec6 '/aura/rf_presence_hint'\cf5 \strokec5 ,\cf4 \strokec4  \cf7 \strokec7 10\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf8 \strokec8 # Declare parameters for more realistic simulation\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .declare_parameter\cf5 \strokec5 (\cf6 \strokec6 'sensor_range'\cf5 \strokec5 ,\cf4 \strokec4  \cf7 \strokec7 10.0\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .declare_parameter\cf5 \strokec5 (\cf6 \strokec6 'wall_attenuation'\cf5 \strokec5 ,\cf4 \strokec4  \cf7 \strokec7 0.5\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .declare_parameter\cf5 \strokec5 (\cf6 \strokec6 'detection_probability'\cf5 \strokec5 ,\cf4 \strokec4  \cf7 \strokec7 1.0\cf5 \strokec5 )\cf4 \strokec4  \cf8 \strokec8 # 1.0 = 100% chance\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .declare_parameter\cf5 \strokec5 (\cf6 \strokec6 'positional_noise_stddev'\cf5 \strokec5 ,\cf4 \strokec4  \cf7 \strokec7 0.0\cf5 \strokec5 )\cf4 \strokec4  \cf8 \strokec8 # Standard deviation in meters\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .timer = \cf2 \strokec2 self\cf4 \strokec4 .create_timer\cf5 \strokec5 (\cf7 \strokec7 0.1\cf5 \strokec5 ,\cf4 \strokec4  \cf2 \strokec2 self\cf4 \strokec4 .timer_callback\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .latest_gt = \cf5 \strokec5 \{\}\cf4 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 def\cf4 \strokec4  gt_callback\cf5 \strokec5 (\cf2 \strokec2 self\cf5 \strokec5 ,\cf4 \strokec4  msg\cf5 \strokec5 ):\cf4 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .latest_gt\cf5 \strokec5 [\cf4 \strokec4 msg.header.frame_id\cf5 \strokec5 ]\cf4 \strokec4  = msg.pose.position\cb1 \
\
\cb3     \cf2 \strokec2 def\cf4 \strokec4  timer_callback\cf5 \strokec5 (\cf2 \strokec2 self\cf5 \strokec5 ):\cf4 \cb1 \strokec4 \
\cb3         sensor_range = \cf2 \strokec2 self\cf4 \strokec4 .get_parameter\cf5 \strokec5 (\cf6 \strokec6 'sensor_range'\cf5 \strokec5 )\cf4 \strokec4 .get_parameter_value\cf5 \strokec5 ()\cf4 \strokec4 .double_value\cb1 \
\cb3         wall_attenuation = \cf2 \strokec2 self\cf4 \strokec4 .get_parameter\cf5 \strokec5 (\cf6 \strokec6 'wall_attenuation'\cf5 \strokec5 )\cf4 \strokec4 .get_parameter_value\cf5 \strokec5 ()\cf4 \strokec4 .double_value\cb1 \
\cb3         detection_probability = \cf2 \strokec2 self\cf4 \strokec4 .get_parameter\cf5 \strokec5 (\cf6 \strokec6 'detection_probability'\cf5 \strokec5 )\cf4 \strokec4 .get_parameter_value\cf5 \strokec5 ()\cf4 \strokec4 .double_value\cb1 \
\cb3         noise_stddev = \cf2 \strokec2 self\cf4 \strokec4 .get_parameter\cf5 \strokec5 (\cf6 \strokec6 'positional_noise_stddev'\cf5 \strokec5 )\cf4 \strokec4 .get_parameter_value\cf5 \strokec5 ()\cf4 \strokec4 .double_value\cb1 \
\
\cb3         msg_list = AuraRfHintList\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\cb3         msg_list.header.stamp = \cf2 \strokec2 self\cf4 \strokec4 .get_clock\cf5 \strokec5 ()\cf4 \strokec4 .now\cf5 \strokec5 ()\cf4 \strokec4 .to_msg\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf2 \strokec2 for\cf4 \strokec4  target_id\cf5 \strokec5 ,\cf4 \strokec4  pos \cf2 \strokec2 in\cf4 \strokec4  \cf2 \strokec2 self\cf4 \strokec4 .latest_gt.items\cf5 \strokec5 ():\cf4 \cb1 \strokec4 \
\cb3             \cf8 \strokec8 # 1. Check for detection probability\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  random.random\cf5 \strokec5 ()\cf4 \strokec4  > detection_probability\cf5 \strokec5 :\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 continue\cf4 \strokec4  \cf8 \strokec8 # Target was not detected in this frame\cf4 \cb1 \strokec4 \
\
\cb3             d = math.sqrt\cf5 \strokec5 (\cf4 \strokec4 pos.x**\cf7 \strokec7 2\cf4 \strokec4  + pos.y**\cf7 \strokec7 2\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 if\cf4 \strokec4  d < sensor_range\cf5 \strokec5 :\cf4 \cb1 \strokec4 \
\cb3                 hint = AuraRfHint\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\cb3                 \cb1 \
\cb3                 \cf8 \strokec8 # 2. Add positional noise\cf4 \cb1 \strokec4 \
\cb3                 hint.x = pos.x + random.gauss\cf5 \strokec5 (\cf7 \strokec7 0\cf5 \strokec5 ,\cf4 \strokec4  noise_stddev\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3                 hint.y = pos.y + random.gauss\cf5 \strokec5 (\cf7 \strokec7 0\cf5 \strokec5 ,\cf4 \strokec4  noise_stddev\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3                 \cb1 \
\cb3                 \cf8 \strokec8 # Simplified signal strength model\cf4 \cb1 \strokec4 \
\cb3                 signal = \cf7 \strokec7 1.0\cf4 \strokec4  / \cf5 \strokec5 (\cf4 \strokec4 d**\cf7 \strokec7 2\cf4 \strokec4  + \cf7 \strokec7 1.0\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3                 \cb1 \
\cb3                 \cf8 \strokec8 # Simple wall model: if target is in a different "room" (quadrant)\cf4 \cb1 \strokec4 \
\cb3                 \cf2 \strokec2 if\cf4 \strokec4  pos.x * \cf7 \strokec7 0\cf4 \strokec4  < \cf7 \strokec7 0\cf4 \strokec4  \cf2 \strokec2 or\cf4 \strokec4  pos.y * \cf7 \strokec7 0\cf4 \strokec4  < \cf7 \strokec7 0\cf5 \strokec5 :\cf4 \cb1 \strokec4 \
\cb3                     signal *= wall_attenuation\cb1 \
\
\cb3                 hint.signal = signal\cb1 \
\cb3                 msg_list.hints.append\cf5 \strokec5 (\cf4 \strokec4 hint\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\
\cb3         \cf2 \strokec2 self\cf4 \strokec4 .publisher_.publish\cf5 \strokec5 (\cf4 \strokec4 msg_list\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 def\cf4 \strokec4  main\cf5 \strokec5 (\cf4 \strokec4 args=\cf2 \strokec2 None\cf5 \strokec5 ):\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     rclpy.init\cf5 \strokec5 (\cf4 \strokec4 args=args\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3     node = MockRfNode\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\cb3     rclpy.spin\cf5 \strokec5 (\cf4 \strokec4 node\cf5 \strokec5 )\cf4 \cb1 \strokec4 \
\cb3     node.destroy_node\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\cb3     rclpy.shutdown\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 __name__\cf4 \strokec4  == \cf6 \strokec6 '__main__'\cf5 \strokec5 :\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     main\cf5 \strokec5 ()\cf4 \cb1 \strokec4 \
\
}